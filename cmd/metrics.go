package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"io"
	"net/http"
	"os/exec"
)

const (
	listenAddr = "0.0.0.0"
	listenPort = "8080"
)

type ReqHandler struct {
	kubeconfig string
}

func (h *ReqHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if r.URL.Path == "/metrics" {
		serveMetrics(w, h.kubeconfig)
		return
	}

	w.WriteHeader(http.StatusOK)
	http.Redirect(w, r, "/metrics", http.StatusMovedPermanently)
}

func serveMetrics(w http.ResponseWriter, kubeconfig string) {
	out := bytes.NewBuffer(nil)
	errOut := bytes.NewBuffer(nil)
	cmd := exec.Command("/usr/local/bin/oc", "get", "--raw", "/metrics", "--kubeconfig", kubeconfig)
	cmd.Stdout = out
	cmd.Stderr = errOut

	if err := cmd.Run(); err != nil {
		fmt.Printf("error: %v\n", err)
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintf(w, "error: %v\n\n%v\n", err, errOut.String())
		return
	}

	w.WriteHeader(http.StatusOK)
	fmt.Fprintf(w, "%s\n", out.String())
}

func serveMetricsConcurrent(w http.ResponseWriter) {
	errOut := bytes.NewBuffer(nil)

	cmd := exec.Command("/usr/local/bin/oc", "get", "--raw", "/metrics", "--kubeconfig", "/home/jvallejo/gopaths/operator/src/github.com/openshift/installer/auth/kubeconfig")
	cmd.Stderr = errOut
	out, err := cmd.StdoutPipe()
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintf(w, "error: %v\n", err)
		return
	}

	errorChan := make(chan error)
	scanner := bufio.NewScanner(out)
	stop := false

	w.WriteHeader(http.StatusPartialContent)
	go concurrentRunCmd(cmd, errorChan)

	for {
		select {
		case err := <-errorChan:
			stop = true
			if err == nil {
				break
			}

			fmt.Fprintf(w, "error: %v\n\n%s\n", err, errOut.String())
			return
		default:
			if scanner.Scan() {
				t := scanner.Text()
				fmt.Fprintf(w, "%s\n", t)
			}

			if err := scanner.Err(); err != nil && err == io.EOF {
				stop = true
				break
			} else if err != nil {
				fmt.Printf("ERR scanner error: %v\n", err)
				stop = true
				break
			}
		}

		if stop {
			break
		}

		if f, ok := w.(http.Flusher); ok {
			f.Flush()
		}
	}

	fmt.Printf("Successfully served /metrics\n")
}

func concurrentRunCmd(cmd *exec.Cmd, errChan chan error) {
	if err := cmd.Run(); err != nil {
		errChan <- err
		return
	}

	errChan <- nil
}

func main() {
	handler := &ReqHandler{}

	flag.StringVar(&handler.kubeconfig, "kubeconfig", "", "Absolute path to the kubeconfig generated by the OpenShift installer")
	flag.Parse()

	if len(handler.kubeconfig) == 0 {
		panic("A --kubeconfig location must be specified.")
	}

	server := &http.Server{
		Addr:    fmt.Sprintf("%s:%s", listenAddr, listenPort),
		Handler: handler,
	}

	fmt.Printf("Listening at %v on port %v\n", listenAddr, listenPort)
	fmt.Printf("Using kubeconfig file: %s\n", handler.kubeconfig)
	if err := server.ListenAndServe(); err != nil {
		panic(err)
	}
}
